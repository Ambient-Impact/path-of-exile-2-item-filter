# @see https://gitlab.com/explore/catalog/to-be-continuous/make

include:
  - component: $CI_SERVER_FQDN/to-be-continuous/make/gitlab-ci-make@1.5.0
    inputs:
      # Don't use the slim image because that doesn't have make.
      image: 'python:3'

variables:
  ITEM_FILTER_DIR: AmbientImpactItemFilter
  ITEM_FILTER_FILE: Ambient.Impact.filter
  MAKE_BUILD_ARGS: build filter-dir=$ITEM_FILTER_DIR outfile=$ITEM_FILTER_FILE
  ARCHIVE_NAME: $ITEM_FILTER_FILE.zip
  PACKAGE_NAME: item-filter

.make-base:
  cache:
    paths:
      - $ITEM_FILTER_DIR/.venv/
  artifacts:
    paths:
      - $ITEM_FILTER_DIR/sounds/**/*.mp3
      - $ITEM_FILTER_DIR/sounds/**/*.md
      - $ITEM_FILTER_FILE
      - license.md
      - readme.md

make-build:
  rules:
    # Disable the default component job in favour of our 'build' job.
    - when: never

build:
  extends: .make-base
  stage: build
  # Disable cache so that we can test the virtual environment creation and
  # installation of Jinja.
  cache: []
  before_script:
    # This allows extending the before_script from .make-base.
    - !reference [.make-base, before_script]
    - apt-get -qq update
    - apt-get install -y jq
  script:
    - make ${TRACE+-d} $MAKE_BUILD_ARGS
  rules:
    - if:
      changes:
        - $ITEM_FILTER_DIR/**/*.j2
        - $ITEM_FILTER_DIR/**/*.json
        - .gitlab-ci.yml
        - makefile

package:
  extends: .make-base
  stage: package-build
  needs:
    - job: build
      artifacts: true
  before_script:
    # This allows extending the before_script from .make-base.
    - !reference [.make-base, before_script]
    - apt-get -qq update
    - apt-get install -y zip
  script:
    - |
      ls -la
      echo "${ARCHIVE_NAME} ${ITEM_FILTER_FILE}"
      zip -9 ${ARCHIVE_NAME} ${ITEM_FILTER_FILE}
      zip -9 ${ARCHIVE_NAME} license.md
      zip -9 ${ARCHIVE_NAME} readme.md
      find "${ITEM_FILTER_DIR}/sounds" \( -name "*.mp3" -o -name "*.md" \) -exec zip -9 ${ARCHIVE_NAME} '{}' \; | sort -V
  artifacts:
    paths:
      - $ARCHIVE_NAME

.release-only:
  rules:
    # Run this when a tag is created using semantic versioning.
    #
    # @see https://stackoverflow.com/questions/73003885/trigger-gitlab-ci-pipeline-only-when-there-is-a-new-tag-with-some-rules
    # - if: $CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+.*/
    - if: $CI_COMMIT_TAG

publish:
  extends: .release-only
  stage: publish
  needs:
    - job: package
      artifacts: true
  script:
    # @see https://docs.gitlab.com/user/packages/generic_packages/#publish-a-single-file
    - |
      curl --location --user "gitlab-ci-token:${CI_JOB_TOKEN}" \
           --upload-file ${ARCHIVE_NAME} \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PACKAGE_NAME}/${CI_COMMIT_TAG}/${ARCHIVE_NAME}"

release:
  extends: .release-only
  stage: publish
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - job: build
      artifacts: true
    - job: publish
      artifacts: true
  script:
    - echo "Creating release $CI_COMMIT_TAG."
  release:
    tag_name: '$CI_COMMIT_TAG'
    description: '$CI_COMMIT_TAG'
    # assets:
    #   links:
    #     - name: 'item-filter-dev.zip'
    #       url: ${ARTIFACT_URL}
    #       filepath: '/assets/item-filter-dev.zip'
